

\documentclass[10pt]{article}
\usepackage{tikz}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{dashbox}
\usepackage{alltt}
\usepackage{blindtext}
\usepackage{graphicx}



\title{ЛОШ ФМЛ информатика, день 3}
\date{24.08.2022}



\usepackage[left=10mm, top=10mm, right=10mm, bottom=15mm, nohead, footskip=10mm]{geometry}
\sectionfont{\fontsize{10}{10}\selectfont}
\begin{document}
    %\maketitle
\begin{center}
    \Large
    \textbf{ЛОШ ФМЛ информатика, день 3}
    \vspace{0.4cm}
    \large
    \\
    24 августа 2022
\end{center}
    \section{Мощности компьютеров}
    \section{Временная асимптотика алгоритмов}
    \section{std::vector}
    \begin{alltt}
#include<vector>
int n = 10; // размер вектора
vector<int> A(n , 1) // 1 - изначально заполняемый элемент
A.push_back(2) // добавить в конец 2
    \end{alltt}
    \section{Битовые операции}
        \begin{enumerate} 
            \item побитовый \textbf{OR} 
            \item  побитовый \textbf{AND} 
            \item  побитовый \textbf{XOR}
            \item  побитовый \textbf{NOT}
            \item  сдвиг влево и сдвиг вправо
        \end{enumerate}
    \section{Задача на кратность}
    Как проверить делится ли число $a$ на $2^n$ не используя $\%$ (остаток от деления)?
    \\ 
    \rotatebox{180}{\textbf{Ответ}: (a | (1 << n)) == (1 << n) или ((a >> n) << n) == a}
    \section{Представление множеств}
    Все числа в памяти представлены в двоичной системе исчесления.
    \\
    \textbf{Идея}: пусть элементы множества это позиции (в 0-нумерации) единичных битов.Тогда каждое число задает свое кникальное множество
    \\
    \textbf{Пример}: $1242 = 10011011010_2$ задает множество $\{1 , 3 , 4 , 6 , 7 , 10\}$ (позиции едичных битов)
    \section{Подпоследовательность и подотрезок массива}
       \textbf{Подотрезок} массива это массив который может получен путем удаление элементов из \textbf{начала} и или \textbf{конца} исходного массива.
       \vspace{5mm}
       \\
    \textbf{Подпоследовательность} массива это массив который может получен путем удаление элементов из \textbf{любого} места исходного массива.
    
    \section{Задача о количестве объектов}
    
    Дан массив $A$ длиной $n$, нужно найти количество его  подпоследовательностей и количество подотрезков.
    \\
    \\
    \rotatebox{180}{\textbf{Ответ}: $2^n$ и $\frac{n(n + 1)}{2}$}
    
    
    \section{Задачи о количестве объектов с заданными храктеристиками}
    
    Дан массив $A$ , $A_i \leq 10^9$ длиной $n \leq {10^3}$, нужно найти нужно найти количество его  количество подотрезков с четной суммой.
    \\
    \\
    Решите предыдущую задачу при $n \leq {10^5}$.
    \\
    \\
    Дан массив $A$, $A_i \leq 10^9$ длиной $n \leq {20}$, нужно найти количество его  количество подпоследовательностей с четной суммой.
    \\
    \\
    \textbf{(hard)}Решите предыдущую задачу при $n \leq {10^5}$ и найдите остакток от деления ответа на $10^9 + 7$ или же решите задачу по модулю $10^9 + 7$.
    \\
    \textbf{Примечание}:  $10^9 + 7$ простое число.
    \section{Модульная арифметика}
        $(a + b)\%MOD = (a\%MOD + b\%MOD)\%MOD$
        \\
        \\
        $(a * b)\%MOD = (a\%MOD * (b\%MOD))\%MOD$
        \\
        \\
        $(a - b)\%MOD = (a\%MOD - b\%MOD)\%MOD$
        
    \section{Быстрое возведение в степень по модулю}
        $a ^ n = {(a ^ \frac{n}{2})}^ 2$ если n четное.
        \\
        $a ^ n = {a  a ^ {(n - 1)}}$ если n нечетное.
        \\
        $a^n = 1$ если n = 0.
        \\
        все опепрации кончно же по модулю
    \begin{alltt}
int pw(int a, int b, int MOD)\{
    if(!b) return 1;
    if(b % 2) return (1ll * a * pw(a ,  b - 1 , MOD)) % MOD;
    int x = pw(a , b / 2, MOD);
    return (1ll * x * x) % MOD;
\}
    \end{alltt}
    
    \section{Малая теорема Ферма (МТФ)}
    Если $p$ — простое число и a — целое число, не делящееся на $p$, то $a^{p-1}-1$ делится на $p$.
    \\
    Более формально: $a^{p - 1} - 1 \equiv 0 \mod p$.
    \\
    Добавим 1 к левой и правой части: $a^{p - 1} \equiv 1 \mod p$
    
    \section{Деление по простому модулю}
    $b / a  \equiv b * a ^ {-1} \mod MOD$
    теперь нам нужно найти $a^{-1}$, то есть такое число которое при умножении на $a$ дает $1$
    вернемся к МТФ: $a^{p - 1} \equiv 1 \mod p$ и представим $a^{p - 1} = aa^{p - 2}$ тогда:
    $aa^{p - 2} \equiv 1 \mod p$ следовательно $a^{p-2} \equiv a^{-1} \mod p $
    и получаем равентсво : 
    
    \begin{center}
        $b / a \equiv ba^{MOD - 2} \mod MOD $
    \end{center}
    
    \section{Комбинаторные объекты по модулю}
    $\binom{n}{k} \equiv \frac{n!}{k!(n-k)!} \equiv n!(k!(n-k)!)^{MOD-2} \mod MOD$ 
    
    \section{Основная теорема арифметики (ОТА)}
    Любое натуральное число больше единицы может быть разложено в виде простых множителей и это разложение единственно (если не учитывать порядок множителей).
    \section{Решето Эратосфена}
    
    Оценка временной сложности:
    \\
    $\mathcal{O}(\sum\limits_{i=1}^n\lfloor \frac{n}{i} \rfloor) = \mathcal{O}(n\sum\limits_{i=1}^n \frac{1}{i})  =  \mathcal{O}(n \int\limits_{1}^n \frac{1}{x}\,dx) = \mathcal{O}(n \ln n) = \mathcal{O}(n \log n)$
    
    \section{Алгоритм Евклида}
        \begin{alltt}
int gcd(int a, int b) \{
    if (b == 0)
        return a;
    return gcd(b, a % b);
\}
    \end{alltt}
или встроенная функия
    \begin{alltt}
#include<algorithm>
__gcd(a , b);
    \end{alltt}
    \section{Задача про НОД} Дан массив $A$ , $A_i \leq 10^9$  длиной $n \leq 10^5$ найти НОД (наибольший общий делитель) всех его элементов.
    \\
    Оцините временную сложность вашего алгоритма.
    \\
    \rotatebox{180}{\textbf{Ответ}: $\mathcal{O}(n + \log (\max{A_i}))$ а не $\mathcal{O}(n \log (\max{A_i}))$!!!}
    
    \section{(hard) Задача про НОД}
    Дан массив $A$ , $A_i \leq 10^5$  длиной $n \leq 10^5$ найти максимальнай НОД по всем возможным парам элементов, пары из одинаковых индексов не считать.
    \\
    \rotatebox{180}{\textbf{Подсказка №1}: ограниечение на $A_i$ меньше чем обычно.}
    \\
    \rotatebox{180}{\textbf{Подсказка №2}: подумайте об $\mathcal{O}(C \log C + n)$ или $\mathcal{O}(C+ n \sqrt C)$ или об $\mathcal{O}(C+ n \sqrt[3] C)$*, где $C = \max A_i$.}
    
    \section{Задача о поиске подотрезка с максимальной суммой}
    Пусть дан массив целых чисел $A$ , $|A_i| \leq 10^9$  длиной $n \leq 10^2$ найти отрезок с максимальной суммой.
    \\
    Решите эту же задачу при $n \leq 5*10^3$.
    \\
    Решите эту же задачу при $n \leq 10^6$.
    
    \section{std::set и std::map}
        \begin{alltt}
#include<set>
set<int> A;
A.insert(2); // добавить 2
A.erase(2); // удалть 2
cout << A.count(2); // проверить на существование 
    \end{alltt}
    \section{(Hard) Для тех кому скучно №1.} 
    Дан массив натуральных чисел $A$ , $A_i \leq 2*10^7$  длиной $n \leq 5*10^4$ разрешается прибавлять или вычетать из любого элемента по 1 , но количество операций не должно привосходить $n$ какой максимальный НОД всех элементов вы сможете получить?
    \\
    Ограничение: 3 секунды и 2048 мБ.
    \\
    \rotatebox{180}{\textbf{Подсказка №1}: Сколько элементов изменяютя не болле чем на 1?}
    \\
    \rotatebox{180}{\textbf{Подсказка №2}: Если мы знаем какое число находиться в оптимальном массиве, как узнать ответ?}
    \\
    \rotatebox{180}{\textbf{Подсказка №3}: Что там по метеоритам?}
    
    \section{(HARD) Для тех кому скучно №2.}
    Даны три натуральных числа $a$ , $b$ и $p$ такие что $a , b < p$ и $p$ -  \textbf{простое}.
    Разрешается делать над $a$ дествия трех видов:
    \begin{enumerate} 
        \item заменить $a$ на $(a + 1)\mod p$
        \item заменить $a$ на $(a - 1)\mod p$
        \item заменить $a$ на $a ^ {p -2}\mod p$
    \end{enumerate}
    Нужно за $300$ операций (можно меньше) превратить $a$ в $b$. Требется найти последовательность действий.
    Если ответов несколько выбирете любой.
    \\
    Для каких ограничений на $p$ вы умеете решать данную задачу с ограничением по времени 3 секунды и по памяти 2048 мБ?
    \\
    \rotatebox{180}{\textbf{Подсказка №1}: Вы же написали динамическое программирование?}
    \\
    \rotatebox{180}{\textbf{Подсказка №2}: Забудьте о ДП, подумайте о днях рождения и о BFS.}
    
    
\end{document}
